[
    {
        "thought": "Do not use memory module",
        "name": "None",
        "module type": "memory",
        "code": "None",
        "performance": 0
    },
    {
        "thought": "Store the task resolution trajectory. Based on the task name to retrieve the relevant task solving trajectory",
        "name": "DILU",
        "module type": "memory",
        "code": "class MemoryDILU(MemoryBase):\n    def __init__(self, llms_type, agent_id) -> None:\n        super().__init__(llms_type, 'dilu', agent_id)\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query scenario\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]        \n        \n        # Return empty string if memory is empty\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memory\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=1)\n            \n        # Extract task trajectories from results\n        task_trajectories = [\n            result[0].metadata['task_trajectory'] for result in similarity_results\n        ]\n        \n        # Join trajectories with newlines and return\n        return '\n'.join(task_trajectories)\n\n    def addMemory(self, current_situation):\n        # Extract task description\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])\n    ",
        "performance": 0.74
    },
    {
        "thought": "Store the task resolution trajectories. Retrieve relevant task-solving trajectories based on the task name, and select the one that the LLM considers most important",
        "name": "Generative",
        "module type": "memory",
        "code": "class MemoryGenerative(MemoryBase):\n    def __init__(self, llms_type, agent_id) -> None:\n        super().__init__(llms_type, 'generative', agent_id)\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty if no memories exist\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Get top 3 similar memories\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=3)\n            \n        fewshot_results = []\n        importance_scores = []\n\n        # Score each memory's relevance\n        for result in similarity_results:\n            trajectory = result[0].metadata['task_trajectory']\n            fewshot_results.append(trajectory)\n            \n            # Generate prompt to evaluate importance\n            prompt = f'''You will be given a successful case where you successfully complete the task. Then you will be given an ongoing task. Do not summarize these two cases, but rather evaluate how relevant and helpful the successful case is for the ongoing task, on a scale of 1-10.\nSuccess Case:\n{trajectory}\nOngoing task:\n{query_scenario}\nYour output format should be:\nScore: '''\n\n            # Get importance score\n            response = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1, stop_strs=['\n'])\n            score = int(re.search(r'\\d+', response).group()) if re.search(r'\\d+', response) else 0\n            importance_scores.append(score)\n\n        # Return trajectory with highest importance score\n        max_score_idx = importance_scores.index(max(importance_scores))\n        return similarity_results[max_score_idx][0].metadata['task_trajectory']\n    \n    def addMemory(self, current_situation):\n        # Extract task description\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])\n    ",
        "performance": 0.64
    },
    {
        "thought": "Store the task resolution trajectories. Retrieve relevant task-solving trajectories based on the task name, and output guidance to heuristically assist the LLM in completing the current task",
        "name": "TP",
        "module type": "memory",
        "code": "class MemoryTP(MemoryBase):\n    def __init__(self, llms_type, agent_id) -> None:\n        super().__init__(llms_type, 'tp', agent_id)\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from scenario\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty if no memories exist\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memory\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=1)\n            \n        # Generate plans based on similar experiences\n        experience_plans = []\n        task_description = 'You are in the' + query_scenario.rsplit('You are in the', 1)[1]\n        \n        for result in similarity_results:\n            prompt = f'''You will be given a successful case where you successfully complete the task. Then you will be given an ongoing task. Do not summarize these two cases, but rather use the successful case to think about the strategy and path you took to attempt to complete the task in the ongoing task. Devise a concise, new plan of action that accounts for your task with reference to specific actions that you should have taken. You will need this later to solve the task. Give your plan after \"Plan\".\nSuccess Case:\n{result[0].metadata['task_trajectory']}\nOngoing task:\n{task_description}\nPlan:\n'''\n            experience_plans.append(llm_response(prompt=prompt, model=self.llm_type, temperature=0.1))\n            \n        return 'Plan from successful attempt in similar task:\n' + '\n'.join(experience_plans)\n\n    def addMemory(self, current_situation):\n        # Extract task name\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])\n    ",
        "performance": 0.36
    },
    {
        "thought": "Store the task resolution trajectory, and summarize the task resolutiong trajectory. Based on the task summary to retrieve relevant the task resolution trajectory",
        "name": "Voyager",
        "module type": "memory",
        "code": "class MemoryVoyager(MemoryBase):\n    def __init__(self, llms_type, agent_id) -> None:\n        super().__init__(llms_type, 'voyager', agent_id)\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty if no memories exist\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memories\n        similarity_results = self.scenario_memory.similarity_search_with_score(task_name, k=1)\n        \n        # Extract trajectories from results\n        memory_trajectories = [result[0].metadata['task_trajectory'] \n                             for result in similarity_results]\n                             \n        return '\n'.join(memory_trajectories)\n\n    def addMemory(self, current_situation):\n        # Prompt template for summarizing trajectory\n        voyager_prompt = '''You are a helpful assistant that writes a description of the task resolution trajectory.\n\n        1) Try to summarize the trajectory in no more than 6 sentences.\n        2) Your response should be a single line of text.\n\n        For example:\n        Trajectory:\n        You are in the middle of a room. Looking quickly around you, you see a cabinet 10, a cabinet 9, a cabinet 8, a cabinet 7, a cabinet 6, a cabinet 5, a cabinet 4, a cabinet 3, a cabinet 2, a cabinet 1, a coffeemachine 1, a countertop 3, a countertop 2, a countertop 1, a diningtable 1, a drawer 6, a drawer 5, a drawer 4, a drawer 3, a drawer 2, a drawer 1, a fridge 1, a garbagecan 1, a microwave 1, a sinkbasin 1, a stoveburner 4, a stoveburner 3, a stoveburner 2, a stoveburner 1, and a toaster 1.\n        Your task is to: heat some egg and put it in diningtable.\n        > think: To solve the task, I need to find and take an egg, then heat it with microwave, then put it in diningtable.\n        OK.\n        > think: First I need to find an egg. An egg is more likely to appear in fridge (1), countertop (1-3), diningtable (1), stoveburner (1-4), toaster (1), garbagecan (1), cabinet (1-10). I can check one by one, starting with fridge 1.\n        OK.\n        > open fridge 1\n        You open the fridge 1. The fridge 1 is open. In it, you see a lettuce 2, a mug 2, and a potato 3.\n        > go to countertop 1\n        On the countertop 1, you see a bread 1, a fork 1, and a saltshaker 1.\n        > go to countertop 2\n        On the countertop 2, you see nothing.\n        > go to countertop 3\n        On the countertop 3, you see a bowl 1, a butterknife 1, a egg 2, a kettle 2, a plate 1, a sink 1, and a spatula 2.\n        > think: Now I find an egg (2). Next, I need to take it.\n        OK.\n        > take egg 2 from countertop 3\n        You pick up the egg 2 from the countertop 3.\n        > think: Now I take an egg (2). Next, I need go to a microwave (1) and heat it.\n        OK.\n        > go to microwave 1\n        The microwave 1 is closed.\n        > heat egg 2 with microwave 1\n        You heat the egg 2 using the microwave 1.\n        > think: Now I heat an egg (2). Next, I need to put it in/on diningtable 1.\n        OK.\n        > go to diningtable 1\n        On the diningtable 1, you see a apple 2, a bread 3, a egg 1, a kettle 1, a knife 1, a mug 1, a papertowelroll 1, a peppershaker 2, a potato 1, a soapbottle 1, and a spatula 1.\n        > put egg 2 in/on diningtable 1\n        You put the egg 2 in/on the diningtable 1.\n\n        Then you would write: The trajectory is about finding an egg, heating it with a microwave, and placing it on the dining table after checking various locations like the fridge and countertops.\n\n        Trajectory:\n        '''\n        \n        # Generate summarized trajectory\n        prompt = voyager_prompt + current_situation\n        trajectory_summary = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1)\n        \n        # Create document with metadata\n        doc = Document(\n            page_content=trajectory_summary,\n            metadata={\n                \"task_description\": trajectory_summary,\n                \"task_trajectory\": current_situation\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([doc])\n    ",
        "performance": 0.78
    }
]